keep <- x <= cut
c(Pearson_cut = cor(x[keep], y[keep]))
plot(x[keep], y[keep])
# 对比：对x做log变换后再算Pearson（常见修正）
x_log <- log1p(x)
plot(x_log,y)
c(Pearson_logx = cor(x_log, y))
#极端值导致低估
set.seed(123)
x <- 1:40
y <- x + rnorm(40, 0, 5)
x_out <- c(1, 42)
y_out <- c(50, -30)
x_all <- c(x, x_out)
y_all <- c(y, y_out)
plot(x_all, y_all)
cor(x,y)
cor(x_all, y_all)
#极端值导致高估
set.seed(123)
x <- rnorm(40)
y <- rnorm(40)
x_out <- c(5, 8)
y_out <- c(10, 14)
x_all <- c(x, x_out)
y_all <- c(y, y_out)
plot(x_all, y_all)
cor(x, y)
cor(x_all, y_all)
#极端值导致高估
set.seed(123)
x <- rnorm(40)
y <- rnorm(40)
x_out <- c(2, 5)
y_out <- c(10, 14)
x_all <- c(x, x_out)
y_all <- c(y, y_out)
plot(x_all, y_all)
cor(x, y)
cor(x_all, y_all)
#极端值导致高估
set.seed(123)
x <- rnorm(40)
y <- rnorm(40)
x_out <- c(1.8,2.2)
y_out <- c(10, 14)
x_all <- c(x, x_out)
y_all <- c(y, y_out)
plot(x_all, y_all)
cor(x, y)
cor(x_all, y_all)
#极端值导致高估
set.seed(123)
x <- rnorm(40)
y <- rnorm(40)
x_out <- c(1.5, 2)
y_out <- c(10, 14)
x_all <- c(x, x_out)
y_all <- c(y, y_out)
plot(x_all, y_all)
cor(x, y)
cor(x_all, y_all)
x = c(74, 71, 72, 68, 76, 73, 67, 70, 54, 74)
y = c(76, 75, 71, 70, 76, 79, 65, 77, 62, 72)
n = 10
mean_x = mean(x)
mean_y = mean(y)
dev_x = x - mean_x
dev_y = y - mean_y
sum_xy <- sum(dev_x * dev_y)  #两个变量乘积和
sum_x2 <- sum(dev_x^2)
sum_y2 <- sum(dev_y^2)  #和方
r = sum_xy / sqrt(sum_x2 * sum_y2)  #r
print(r)
r * sqrt(n-2) / sqrt(1-r^2)   #t
cor.test(x, y)
# pearson correlation
#cor(hours, stress, method = 'pearson')
cor.test(hours, stress)
rm(list=ls())
library('readxl')
data = read_xlsx('hw10_data.xlsx')
rm(list=ls())
library('readxl')
data = read_xlsx('hw10_data.xlsx')
attach(data)
# pearson correlation
#cor(hours, stress, method = 'pearson')
cor.test(hours, stress)
# spearman correlation
#cor(hours, stress, method = 'spearman')
cor.test(hours, stress, method = 'spearman')
set.seed(2023)
x1 <- rnorm(24,10,2)
x2 <- rnorm(24,5,0.4)
y <- 2*x1+3*x2
example_data <- data.frame(x1 = x1, x2 = x2, y = y)  #创建数据框
#画散点图
plot(x1,y)
# 一元线性模型
model1 <- lm(y~x1, data = example_data)  #拟合的model：y = b*x_1+a
# 多元线性模型不含交互
#model2 <- lm(y~x1+x2, data = example_data)   #拟合的model: y = b_1*x_1+b_2*x_2+a
# 多元线性模型含交互
# model2 <- lm(y~x1+x2+x1:x2,data = example_data)   #拟合的model: y = b_1*x_1+b_2*x_2+b_3*x_1*x_2
summary(model1) #查看结果
View(model1)
View(model1)
(model1$coefficients) #系数，k和b
(model1$residuals)    #残差
set.seed(2023)
x1 <- rnorm(24,10,2)
x2 <- rnorm(24,5,0.4)
y <- 2*x1+3*x2
example_data <- data.frame(x1 = x1, x2 = x2, y = y)  #创建数据框
#画散点图
plot(x1,y)
# 一元线性模型
model1 <- lm(y~x1, data = example_data)  #拟合的model：y = b*x_1+a
# 多元线性模型不含交互
#model2 <- lm(y~x1+x2, data = example_data)   #拟合的model: y = b_1*x_1+b_2*x_2+a
# 多元线性模型含交互
# model2 <- lm(y~x1+x2+x1:x2,data = example_data)   #拟合的model: y = b_1*x_1+b_2*x_2+b_3*x_1*x_2
summary(model1) #查看结果
set.seed(2023)
x1 <- rnorm(24,10,2)
x2 <- rnorm(24,5,0.4)
y <- 2*x1+3*x2
example_data <- data.frame(x1 = x1, x2 = x2, y = y)  #创建数据框
#画散点图
plot(x1,y)
# 一元线性模型
model1 <- lm(y~x1, data = example_data)  #拟合的model：y = b*x_1+a
# 多元线性模型不含交互
model2 <- lm(y~x1+x2, data = example_data)   #拟合的model: y = b_1*x_1+b_2*x_2+a
# 多元线性模型含交互
# model2 <- lm(y~x1+x2+x1:x2,data = example_data)   #拟合的model: y = b_1*x_1+b_2*x_2+b_3*x_1*x_2
summary(model1) #查看结果
View(model2)
summary(model2)
summary(model2)
set.seed(2023)
x1 <- rnorm(24,10,2)
x2 <- rnorm(24,5,0.4)
y <- 2*x1+3*x2
example_data <- data.frame(x1 = x1, x2 = x2, y = y)  #创建数据框
#画散点图
plot(x1,y)
# 一元线性模型
model1 <- lm(y~x1, data = example_data)  #拟合的model：y = b*x_1+a
# 多元线性模型不含交互
model2 <- lm(y~x1+x2, data = example_data)   #拟合的model: y = b_1*x_1+b_2*x_2+a
# 多元线性模型含交互
# model2 <- lm(y~x1+x2+x1:x2,data = example_data)   #拟合的model: y = b_1*x_1+b_2*x_2+b_3*x_1*x_2
summary(model1)
summary(model2)#查看结果
#预测
(model1$fitted.values)
plot(x1,model1$fitted.values)
predict(model1)
#新数据
data <- data.frame(x1 = c(2.5)) # the column name should be the same with the linear model
predict(model1,newdata = data,
interval = 'confidence')   #显示置信区间
#预测
(model1$fitted.values)
predict(model1)
plot(x1, model1$fitted.values)
#新数据
data <- data.frame(x2 = c(2.5)) # the column name should be the same with the linear model
predict(model1,newdata = data,
interval = 'confidence')   #显示置信区间
#预测
(model1$fitted.values)
predict(model1)
plot(x1, model1$fitted.values)
#新数据
data <- data.frame(x2 = c(2.5)) # the column name should be the same with the linear model
predict(model1,newdata = data,
interval = 'confidence')   #显示置信区间
#预测
(model1$fitted.values)
predict(model1)
plot(x1, model1$fitted.values)
#新数据
data <- data.frame(x = c(2.5)) # the column name should be the same with the linear model
predict(model1,newdata = data,
interval = 'confidence')   #显示置信区间
#预测
(model1$fitted.values)
predict(model1)
plot(x1, model1$fitted.values)
#新数据
data <- data.frame(x = rnorm(24,5,0.4)) # the column name should be the same with the linear model
predict(model1,newdata = data,
interval = 'confidence')   #显示置信区间
#预测
(model1$fitted.values)
predict(model1)
plot(x1, model1$fitted.values)
#新数据
data <- data.frame(x = c(2.5)) # the column name should be the same with the linear model
predict(model1,newdata = data,
interval = 'confidence')   #显示置信区间
#预测
(model1$fitted.values)
predict(model1)
plot(x1, model1$fitted.values)
#新数据
data <- data.frame(x = rnorm(24,5,0.4)) # the column name should be the same with the linear model
predict(model1,newdata = data,
interval = 'confidence')   #显示置信区间
#预测
(model1$fitted.values)
predict(model1)
plot(x1, model1$fitted.values)
#新数据
data <- data.frame(x1 = c(2.5)) # the column name should be the same with the linear model
predict(model1,newdata = data,
interval = 'confidence')   #显示置信区间
View(data)
View(data)
#预测
(model1$fitted.values)
predict(model1)
plot(x1, model1$fitted.values)
#新数据
data <- data.frame(x = rnorm(24,5,0.4)) # the column name should be the same with the linear model
predict(model1,newdata = data,
interval = 'confidence')   #显示置信区间
View(data)
View(data)
View(example_data)
View(data)
View(example_data)
View(data)
#预测
(model1$fitted.values)
predict(model1)
plot(x1, model1$fitted.values)
#新数据
data <- data.frame(x2 = rnorm(24,5,0.4)) # the column name should be the same with the linear model
predict(model1,newdata = data,
interval = 'confidence')   #显示置信区间
#预测
(model1$fitted.values)
predict(model1)
plot(x1, model1$fitted.values)
#新数据
data <- data.frame(x1 = rnorm(24,5,0.4)) # the column name should be the same with the linear model
predict(model1,newdata = data,
interval = 'confidence')   #显示置信区间
#预测
(model1$fitted.values)
predict(model1)
plot(x1, model1$fitted.values)
#新数据
data <- data.frame(x1 = c(2.5)) # the column name should be the same with the linear model
predict(model1,newdata = data,
interval = 'confidence')   #显示置信区间
rm(list=ls())
library('readxl')
data = read_excel('demo_data.xlsx')
attach(data)
# 正态性检验
library(rstatix)
data %>%
group_by(Group) %>%
shapiro_test(y)
# 中括号表示条件的限制
shapiro_test(y[Group == "A"])
shapiro_test(y[Group == "B"])
shapiro_test(y[Group == "C"])
data$Group = factor(data$Group,
levels = c("C","B","A"))
#方差齐性
library(carData)
library(car)
leveneTest(y, Group)
#t检验
#单样本
t.test(y, mu = 0, alternative = c("two.sided", "less", "greater"))
#配对样本
#t.test(x, y, paired = TRUE)
#独立样本
#t.test(x, y, var.equal = TRUE)
t.test(y~Class, var.equal = FALSE)
#方差分析
library(bruceR)
result = MANOVA(
data,
dv = NULL, #单因素
dvs = "S1:S2", #重复测量
dvs.pattern = "S(.*)", #定义命名规律
between = "Group", #分组变量
within = "Time", #组内变量
sph.correction= "GG", #违背球形假设的校正
)
EMMEANS(result, effect = "Time", by = "Group", p.adjust = "Scheffe") #固定Group，比较Time
emmip(result, ~ Group, CIs = TRUE)
summary(result)
# summary可以得到准确的SS
# 还是找不到SS，可以去右边的Data栏
View(result)
summary.aov(result)
summary.aov(result)
summary(result)$SS
# summary可以得到准确的SS
# 还是找不到SS，可以去右边的Data栏
summary(result)
lapply(result$aov, summary)
# summary可以得到准确的SS
# 还是找不到SS，可以去右边的Data栏
summary(result)
summary.aov(result$fit)
summary(result)
summary.aov(result$result)
summary(result)
(result$aov)
# summary可以得到准确的SS
# 还是找不到SS，可以去右边的Data栏
summary(result)
(result$aov)
# summary可以得到准确的SS
# 还是找不到SS，可以去右边的Data栏
rm(list=ls())
library('readxl')
data = read_excel('demo_data.xlsx')
attach(data)
# 正态性检验
library(rstatix)
data %>%
group_by(Group) %>%
shapiro_test(y)
# 中括号表示条件的限制
shapiro_test(y[Group == "A"])
shapiro_test(y[Group == "B"])
shapiro_test(y[Group == "C"])
data$Group = factor(data$Group,
levels = c("C","B","A"))
#方差齐性
library(carData)
library(car)
leveneTest(y, Group)
#t检验
#单样本
t.test(y, mu = 0, alternative = c("two.sided", "less", "greater"))
#配对样本
#t.test(x, y, paired = TRUE)
#独立样本
#t.test(x, y, var.equal = TRUE)
t.test(y~Class, var.equal = FALSE)
#方差分析
library(bruceR)
result = MANOVA(
data,
dv = NULL, #单因素
dvs = "S1:S2", #重复测量
dvs.pattern = "S(.*)", #定义命名规律
between = "Group", #分组变量
within = "Time", #组内变量
sph.correction= "GG", #违背球形假设的校正
)
EMMEANS(result, effect = "Time", by = "Group", p.adjust = "Scheffe") #固定Group，比较Time
emmip(result, ~ Group, CIs = TRUE)
View(result)
View(result)
summary(result)
# summary可以得到准确的SS
# 还是找不到SS，可以去右边的Data栏
View(result)
View(result)
rm(list=ls())
library('readxl')
data = read_excel('demo_data.xlsx')
attach(data)
# 正态性检验
library(rstatix)
data %>%
group_by(Group) %>%
shapiro_test(y)
# 中括号表示条件的限制
shapiro_test(y[Group == "A"])
shapiro_test(y[Group == "B"])
shapiro_test(y[Group == "C"])
data$Group = factor(data$Group,
levels = c("C","B","A"))
#方差齐性
library(carData)
library(car)
leveneTest(y, Group)
#t检验
#单样本
t.test(y, mu = 0, alternative = c("two.sided", "less", "greater"))
#配对样本
#t.test(x, y, paired = TRUE)
#独立样本
#t.test(x, y, var.equal = TRUE)
t.test(y~Class, var.equal = FALSE)
#方差分析
library(bruceR)
result = MANOVA(
data,
dv = NULL, #单因素
dvs = "S1:S2", #重复测量
dvs.pattern = "S(.*)", #定义命名规律
between = "Group", #分组变量
within = "Time", #组内变量
sph.correction= "GG", #违背球形假设的校正
)
EMMEANS(result, effect = "Time", by = "Group", p.adjust = "Scheffe") #固定Group，比较Time
emmip(result, ~ Group, CIs = TRUE,at = list (x = c("A","B","C")))
#
rm(list=ls())
library('readxl')
data = read_excel('demo_data.xlsx')
attach(data)
# 正态性检验
library(rstatix)
data %>%
group_by(Group) %>%
shapiro_test(y)
# 中括号表示条件的限制
shapiro_test(y[Group == "A"])
shapiro_test(y[Group == "B"])
shapiro_test(y[Group == "C"])
data$Group = factor(data$Group,
levels = c("C","B","A"))
#方差齐性
library(carData)
library(car)
leveneTest(y, Group)
#t检验
#单样本
t.test(y, mu = 0, alternative = c("two.sided", "less", "greater"))
#配对样本
#t.test(x, y, paired = TRUE)
#独立样本
#t.test(x, y, var.equal = TRUE)
t.test(y~Class, var.equal = FALSE)
#方差分析
library(bruceR)
result = MANOVA(
data,
dv = NULL, #单因素
dvs = "S1:S2", #重复测量
dvs.pattern = "S(.*)", #定义命名规律
between = "Group", #分组变量
within = "Time", #组内变量
sph.correction= "GG", #违背球形假设的校正
)
EMMEANS(result, effect = "Time", by = "Group", p.adjust = "Scheffe") #固定Group，比较Time
emmip(result, ~ Group, CIs = TRUE,at = list(Group = c("A","B","C")))
#
rm(list=ls())
qf(0.001,1,18)
qf((1-0.001)/2,1,18)
qf(1-0.001,1,18)
rm(list=ls())
library(readxl)
library(rstatix)
library(stats)
library(dplyr)
data<-read_excel("hw_11.xlsx")
attach(data)
plot(SleepHours,ReactionTime)
data%>%
group_by()%>%
shapiro_test(SleepHours,ReactionTime)
cor.test(SleepHours,ReactionTime)
lm_results=lm(ReactionTime~SleepHours,data=data)
summary(lm_results)
rm(list=ls())
library(readxl)
library(rstatix)
library(stats)
library(dplyr)
data<-read_excel("hw_11.xlsx")
attach(data)
plot(SleepHours,ReactionTime)
data%>%
group_by()%>%
shapiro_test(SleepHours,ReactionTime)
cor.test(SleepHours,ReactionTime)
lm_results=lm(ReactionTime~SleepHours,data=data)
summary(lm_results)
rm(list=ls())
library(readxl)
library(rstatix)
library(stats)
library(dplyr)
data<-read_excel("hw_11.xlsx")
attach(data)
plot(SleepHours,ReactionTime)
data%>%
group_by()%>%
shapiro_test(SleepHours,ReactionTime)
cor.test(SleepHours,ReactionTime)
lm_results=lm(ReactionTime~SleepHours,data=data)
plot(SleepHours,ReactionTime,abline(lm_results))
plot(SleepHours,ReactionTime,abline(lm_results))
#恒定值不能算相关
x <- rep(5, 10)  # x不变
y <- rnorm(10)
cor(x, y)
# 算临界值
#qt(1 - 0.05/2, df) #双侧t
#qt(1 - 0.05, df)  #单侧t
#qf(1 - 0.05, df1, df2)  #F
# 给统计量算 p 值
pt(0, 50)
pf(f_value, df1, df2)
