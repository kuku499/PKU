# L13.sav
# variables used in the dataset
# continuous variables = age, salary, salbegin, previous experience
# ordinal variables = education
# nominal variables = gender, minority, job categories
library(haven) # read sav file
library(rstatix)
library(bruceR)
#setwd("/Users/kunlinwei/Documents/Documents-MBR/PKU/Courses/Stats.Course/2022Fall")
rm(list = ls()) # clear all the variables in global environment
corr_data <- read_sav("L13.sav")
age <- corr_data$age
salary <- corr_data$salary
begin_salary <- corr_data$salbegin
experience <- corr_data$prevexp
# ---------- 正态性检验部分 ----------
# 使用Shapiro-Wilk检验各变量是否服从正态分布
# check normality
shapiro_test(age)
shapiro_test(salary)
shapiro_test(begin_salary)
shapiro_test(experience)
# ---------- 相关分析部分 ----------
# 1. 双变量相关分析 (薪资和起始薪资)
# pearson correlation
newdata <- corr_data[,c("salary","salbegin")]
# 默认进行Pearson相关分析
Corr(newdata)
Corr(newdata,method = "pearson")
#cor() is from the base library, only for two variables
cor(newdata)
cor(newdata,method="spearman")
# 2. 多变量Pearson相关矩阵
# pearson correlation matrix
newdata1 <- corr_data[,c("age","salary","salbegin","prevexp")]
# 分析年龄、薪资、起始薪资、工作经验间的相关关系
Corr(newdata1)
Corr(newdata1,method = "pearson")
# 3. 包含序数变量的Spearman相关矩阵
# spearman correlation matrix
newdata2 <- corr_data[,c("age","salary","educ")]
# 分析年龄、薪资、教育程度的相关关系
Corr(newdata2,method = "spearman")
# ---------- 可视化部分 ----------
#visualize your results
install.packages('PerformanceAnalytics')
library(PerformanceAnalytics)
# 创建相关性图表，包含直方图和相关系数
chart.Correlation(newdata,histgram = T,color = "black")
# ---------- 可视化部分 ----------
#visualize your results
install.packages('PerformanceAnalytics')
library(PerformanceAnalytics)
# 创建相关性图表，包含直方图和相关系数
chart.Correlation(newdata,histgram = T,color = "black")
install.packages("PerformanceAnalytics")
rm(list=ls())
library('readxl')
data = read_xlsx('hw9_data.xlsx')
data$ID <- as.factor(data$ID)
data$Nation <- as.factor(data$Nation)
SS_nation <- 14.567
SS_snation <- 86.917
SS_context <- 1.570
SS_n_c <- 0.080
SS_c_sn <- 20.613
(df_nation <- 1)
(df_snation <- 98)
(df_context <- 2)
(df_n_c <- 2)
(df_c_sn <- 196)
(MS_nation <- SS_nation/df_nation)
(MS_snation <- SS_snation/df_snation)
(MS_context <- SS_context/df_context)
(MS_n_c <- SS_n_c/df_n_c)
(MS_c_sn <- SS_c_sn/df_c_sn)
(F_nation <- MS_nation/MS_snation)
(F_context <- MS_context/MS_c_sn)
(F_n_c <- MS_n_c/MS_c_sn)
library(bruceR)
res <- MANOVA(data, dvs = 'AIA1:AIA3',dvs.pattern = 'AIA(.)',between = "Nation",within = "Context")
emmip(res,Nation ~ Context, CIs = TRUE)
EMMEANS(res, effect = "Context")
res <- MANOVA(data, dvs = 'DIA1:DIA3',dvs.pattern = 'DIA(.)',between = c('Gender','Nation'),within = 'Context')
#固定Nation，比较Context
EMMEANS(res,effect = "Context", by = "Nation")
#固定Context，比较Nation
EMMEANS(res,effect = "Nation", by = "Context")
# 画图
emmip(res,Nation ~ Context|Gender, CIs = TRUE)
rm(list=ls())
library('readxl')
data = read_xlsx('hw9_data.xlsx')
data$ID <- as.factor(data$ID)
data$Nation <- as.factor(data$Nation)
SS_nation <- 14.567
SS_snation <- 86.917
SS_context <- 1.570
SS_n_c <- 0.080
SS_c_sn <- 20.613
(df_nation <- 1)
(df_snation <- 98)
(df_context <- 2)
(df_n_c <- 2)
(df_c_sn <- 196)
(MS_nation <- SS_nation/df_nation)
(MS_snation <- SS_snation/df_snation)
(MS_context <- SS_context/df_context)
(MS_n_c <- SS_n_c/df_n_c)
(MS_c_sn <- SS_c_sn/df_c_sn)
(F_nation <- MS_nation/MS_snation)
(F_context <- MS_context/MS_c_sn)
(F_n_c <- MS_n_c/MS_c_sn)
library(bruceR)
res <- MANOVA(data, dvs = 'AIA1:AIA3',dvs.pattern = 'AIA(.)',between = "Nation",within = "Context")
emmip(res,Nation ~ Context, CIs = TRUE)
EMMEANS(res, effect = "Context")
res <- MANOVA(data, dvs = 'DIA1:DIA3',dvs.pattern = 'DIA(.)',between = c('Gender','Nation'),within = 'Context')
#固定Nation，比较Context
EMMEANS(res,effect = "Context", by = "Nation")
#固定Context，比较Nation
EMMEANS(res,effect = "Nation", by = "Context")
# 画图
emmip(res,Nation ~ Context|Gender, CIs = TRUE)
rm(list=ls())
library('readxl')
data = read_xlsx('hw9_data.xlsx', sheet = 2)
data$Group <- as.factor(data$Group)
library(bruceR)
res <- MANOVA(data, dvs = 'Pre:Post',dvs.pattern = '(.*)',
between = "Group",within = "Time",
sph.correction="GG")
#固定Group，比较Time
EMMEANS(res,effect = "Time", by = "Group")
rm(list=ls())
library('readxl')
data = read_xlsx('hw9_data.xlsx', sheet = 2)
data$Group <- as.factor(data$Group)
res <- MANOVA(data, dvs = 'Pre:Post',dvs.pattern = '(.*)',
between = "Group",within = "Time",
sph.correction="GG")
#固定Group，比较Time
EMMEANS(res,effect = "Time", by = "Group")
View(data)
rm(list=ls())
library('readxl')
data = read_xlsx('hw9_data.xlsx', sheet = 2)
data$Group <- as.factor(data$Group)
res <- MANOVA(data, dvs = 'Pre:Post',dvs.pattern = '(.*)',
between = "Group",within = "Time",
sph.correction="GG")
#固定Group，比较Time
EMMEANS(res,effect = "Time", by = "Group")
rm(list=ls())
library('readxl')
data = read_xlsx('hw9_data.xlsx', sheet = 2)
data$Group <- as.factor(data$Group)
res <- MANOVA(data, dvs = 'Pre:Post',dvs.pattern = '(.*)',
between = "Group",within = "Time",
sph.correction="GG")
#固定Group，比较Time
EMMEANS(res,effect = "Time", by = "Group")
rm(list=ls())
library('readxl')
data = read_xlsx('hw9_data.xlsx', sheet = 2)
data$Group <- as.factor(data$Group)
res <- MANOVA(data, dvs = 'Pre:Post',dvs.pattern = '(.*)',
between = "Group",within = "Time",
sph.correction="GG")
#固定Group，比较Time
EMMEANS(res,effect = "Time", by = "Group")
rm(list=ls())
library('readxl')
data = read_xlsx('hw9_data.xlsx', sheet = 2)
data$Group <- as.factor(data$Group)
res <- MANOVA(data, dvs = 'Pre:Post',dvs.pattern = '(.*)',
between = "Group",within = "Time",
sph.correction="GG")
#固定Group，比较Time
EMMEANS(res,effect = "Time", by = "Group")
rm(list=ls())
library('readxl')
data = read_xlsx('hw9_data.xlsx', sheet = 2)
data$Group <- as.factor(data$Group)
res <- MANOVA(data, dvs = 'Pre:Post',dvs.pattern = '(.*)',
between = "Group",within = "Time",
sph.correction="GG")
#固定Group，比较Time
EMMEANS(res,effect = "Time", by = "Group")
rm(list=ls())
library('readxl')
data = read_xlsx('hw9_data.xlsx', sheet = 2)
data$Group <- as.factor(data$Group)
res <- MANOVA(data, dvs = 'Pre:Post',dvs.pattern = '(.*)',
between = "Group",within = "Time",
sph.correction="GG")
#固定Group，比较Time
EMMEANS(res,effect = "Time", by = "Group")
rm(list=ls())
library('readxl')
data = read_xlsx('hw9_data.xlsx', sheet = 2)
data$Group <- as.factor(data$Group)
res <- MANOVA(data, dvs = 'Pre:Post',dvs.pattern = '(.*)',
between = "Group",within = "Time",
sph.correction="GG")
#固定Group，比较Time
EMMEANS(res,effect = "Time", by = "Group")
rm(list=ls())
library('readxl')
data = read_xlsx('hw9_data.xlsx', sheet = 2)
data$Group <- as.factor(data$Group)
res <- MANOVA(data, dvs = 'Pre:Post',dvs.pattern = '(.*)',
between = "Group",within = "Time",
sph.correction="GG")
#固定Group，比较Time
EMMEANS(res,effect = "Time", by = "Group")
rm(list=ls())
library('readxl')
data = read_xlsx('hw9_data.xlsx', sheet = 2)
data$Group <- as.factor(data$Group)
res <- MANOVA(data, dv = 'Pre',between = "Group",)
EMMEANS(res,effect= "Group")
rm(list=ls())
library('readxl')
data = read_xlsx('hw9_data.xlsx', sheet = 2)
data$Group <- as.factor(data$Group)
res <- MANOVA(data, dv = 'Pre',between = "Group",)
EMMEANS(res,effect= "Group")
rm(list=ls())
library('readxl')
data = read_xlsx('hw9_data.xlsx', sheet = 2)
data$Group <- as.factor(data$Group)
res <- MANOVA(data, dv = 'Pre',between = "Group",)
EMMEANS(res,effect= "Group")
rm(list=ls())
library('readxl')
data = read_xlsx('hw9_data.xlsx', sheet = 2)
data$Group <- as.factor(data$Group)
res <- MANOVA(data, dv = 'Pre',between = "Group",)
EMMEANS(res,effect= "Group")
# 找到一个示例：A>B 且 B>C 显著，但 A>C 不显著（Tukey HSD）
set.seed(2025)
# 参数（可以自行调整）
muA <- 10
muB <- 8
muC <- 7
sdA <- 1.6
sdB <- 1.0
sdC <- 1.0
nA <- 20
nB <- 12
nC <- 12
max_iter <- 2000
found <- FALSE
iter <- 0
while(!found && iter < max_iter){
iter <- iter + 1
A <- rnorm(nA, mean=muA, sd=sdA)
B <- rnorm(nB, mean=muB, sd=sdB)
C <- rnorm(nC, mean=muC, sd=sdC)
dat <- data.frame(
value = c(A,B,C),
group = factor(rep(c("A","B","C"), times=c(nA,nB,nC)))
)
# 一元方差分析 + Tukey HSD
fit <- aov(value ~ group, data=dat)
tuk <- TukeyHSD(fit, "group", conf.level = 0.95)
# 解析 Tukey 结果，寻找 p 值与拒绝情况
tuk_mat <- as.data.frame(tuk$group)
# rownames 为 "B-A" 或 "A-B" 等，标准化为 "A-B","A-C","B-C"
# 转换行名为统一格式 "A-B","A-C","B-C"
rn <- rownames(tuk_mat)
# TukeyHSD 在 R 中行名通常是 "B-A","C-A","C-B" 之类，处理为一致的"X-Y"
# 我们将行名替换为有序 "A-B","A-C","B-C" 以便判断
# 创建一个小转换函数
normname <- function(s){
# s like "B-A" or "C-A" etc -> produce "A-B"/"A-C"/"B-C"
parts <- unlist(strsplit(s, "-"))
x <- parts[1]; y <- parts[2]
# sort alphabetically but keep original order we want: A-B, A-C, B-C
# create canonical by paste(min,max,sep="-") then map to desired orientation
paste(sort(c(x,y)), collapse="-")
}
keys <- sapply(rn, normname)
pvals <- tuk_mat$`p adj`
names(pvals) <- keys
# Check conditions: we need "A-B" significant, "B-C" significant, "A-C" NOT significant
condA_B <- ifelse(!is.na(pvals["A-B"]) && pvals["A-B"] < 0.05, TRUE, FALSE)
condB_C <- ifelse(!is.na(pvals["B-C"]) && pvals["B-C"] < 0.05, TRUE, FALSE)
condA_Cnot <- ifelse(!is.na(pvals["A-C"]) && pvals["A-C"] >= 0.05, TRUE, FALSE)
if(isTRUE(condA_B) && isTRUE(condB_C) && isTRUE(condA_Cnot)){
found <- TRUE
cat("找到符合条件的实例（迭代次数：", iter, "）\n\n")
cat("各组描述性统计：\n")
print(aggregate(value ~ group, data=dat, FUN=function(x) c(mean=mean(x), sd=sd(x), n=length(x))))
cat("\nANOVA摘要：\n")
print(summary(fit))
cat("\nTukeyHSD 结果：\n")
print(tuk)
cat("\nTukey p-values(整理后)：\n")
print(pvals)
break
}
}
if(!found){
cat("未在", max_iter, "次模拟中找到满足条件的实例。你可以增大 max_iter 或调整参数（均值/标准差/样本量）再试。\n")
}
# 找到一个示例：A>B 且 B>C 显著，但 A>C 不显著（Tukey HSD）
set.seed(2025)
# 参数（可以自行调整）
muA <- 10
muB <- 8
muC <- 7
sdA <- 1.6
sdB <- 0.5
sdC <- 1.8
nA <- 20
nB <- 12
nC <- 12
max_iter <- 2000
found <- FALSE
iter <- 0
while(!found && iter < max_iter){
iter <- iter + 1
A <- rnorm(nA, mean=muA, sd=sdA)
B <- rnorm(nB, mean=muB, sd=sdB)
C <- rnorm(nC, mean=muC, sd=sdC)
dat <- data.frame(
value = c(A,B,C),
group = factor(rep(c("A","B","C"), times=c(nA,nB,nC)))
)
# 一元方差分析 + Tukey HSD
fit <- aov(value ~ group, data=dat)
tuk <- TukeyHSD(fit, "group", conf.level = 0.95)
# 解析 Tukey 结果，寻找 p 值与拒绝情况
tuk_mat <- as.data.frame(tuk$group)
# rownames 为 "B-A" 或 "A-B" 等，标准化为 "A-B","A-C","B-C"
# 转换行名为统一格式 "A-B","A-C","B-C"
rn <- rownames(tuk_mat)
# TukeyHSD 在 R 中行名通常是 "B-A","C-A","C-B" 之类，处理为一致的"X-Y"
# 我们将行名替换为有序 "A-B","A-C","B-C" 以便判断
# 创建一个小转换函数
normname <- function(s){
# s like "B-A" or "C-A" etc -> produce "A-B"/"A-C"/"B-C"
parts <- unlist(strsplit(s, "-"))
x <- parts[1]; y <- parts[2]
# sort alphabetically but keep original order we want: A-B, A-C, B-C
# create canonical by paste(min,max,sep="-") then map to desired orientation
paste(sort(c(x,y)), collapse="-")
}
keys <- sapply(rn, normname)
pvals <- tuk_mat$`p adj`
names(pvals) <- keys
# Check conditions: we need "A-B" significant, "B-C" significant, "A-C" NOT significant
condA_B <- ifelse(!is.na(pvals["A-B"]) && pvals["A-B"] < 0.05, TRUE, FALSE)
condB_C <- ifelse(!is.na(pvals["B-C"]) && pvals["B-C"] < 0.05, TRUE, FALSE)
condA_Cnot <- ifelse(!is.na(pvals["A-C"]) && pvals["A-C"] >= 0.05, TRUE, FALSE)
if(isTRUE(condA_B) && isTRUE(condB_C) && isTRUE(condA_Cnot)){
found <- TRUE
cat("找到符合条件的实例（迭代次数：", iter, "）\n\n")
cat("各组描述性统计：\n")
print(aggregate(value ~ group, data=dat, FUN=function(x) c(mean=mean(x), sd=sd(x), n=length(x))))
cat("\nANOVA摘要：\n")
print(summary(fit))
cat("\nTukeyHSD 结果：\n")
print(tuk)
cat("\nTukey p-values(整理后)：\n")
print(pvals)
break
}
}
if(!found){
cat("未在", max_iter, "次模拟中找到满足条件的实例。你可以增大 max_iter 或调整参数（均值/标准差/样本量）再试。\n")
}
#正态性检验
library(rstatix)
data %>%
group_by(Group) %>%
shapiro_test(Pre,Mid,Post)
rm(list=ls())
library('readxl')
data = read_xlsx('hw9_data.xlsx')
data$Group <- as.factor(data$Group)
#正态性检验
library(rstatix)
data %>%
group_by(Group) %>%
shapiro_test(Pre,Mid,Post)
# 方差同质 + 球形检验 + 方差分析
library(bruceR)
res <- MANOVA(data, dvs = 'Pre:Post',dvs.pattern = '(.*)',
between = "Group",within = "Time",
sph.correction="GG")
#正态性检验
library(rstatix)
data %>%
group_by(Group) %>%
shapiro_test(Pre,Mid,Post)
# 方差同质 + 球形检验 + 方差分析
library(bruceR)
res <- MANOVA(data, dvs = 'Pre:Medium',dvs.pattern = '(.*)',
between = "Group",within = "Time",
sph.correction="GG")
View(data)
#正态性检验
library(rstatix)
data %>%
group_by(Group) %>%
shapiro_test(Pre,Mid,Post)
# 方差同质 + 球形检验 + 方差分析
library(bruceR)
res <- MANOVA(data, dvs = 'Pre:Mid',dvs.pattern = '(.*)',
between = "Group",within = "Time",
sph.correction="GG")
x <- c(156,168,178,192)
y <- c(60,63,75,88)
cor(x,y,method = 'pearson') # pearson相关系数
x <- 0:0.5:4
y <- (x-2)^2
plot(x,y)
cor.test(x,y)
# 当然用cor也可以，但是基本还是需要输出p值
x <- c(156,168,178,192)
y <- c(60,63,75,88)
cor.test(x,y,method = 'spearman') # 相关系数
x <- c(1,2,3,3,4,4,5,6)
y <- x^2
plot(x,y)
cor.test(x,y,method = 'spearman')
cor.test(x,y,method = 'pearson')
x <- c(156,168,178,192)
y <- c(60,63,75,88)
cor(x,y,method = 'pearson') # pearson相关系数
# x有两类
set.seed(2023)
x <-  c(rep('students',5),rep('teachers',5))
# 生成10个均值为10，标准差为1的正态分布随机数
y <-  rnorm(10,10,1)
data <- data.frame(x,y)
# 如果直接进行cor.test发现会报错
# cor.test(x,y)
# 因此我们需要进行编码,编码后直接比较就行了
data$x[data$x == 'students'] = 0
data$x[data$x == 'teachers'] = 1
data$x = as.numeric(data$x)
cor.test(data$x,data$y)
# 如果用更简便的方法
data$identity <- ifelse(data$x == 'students',0,1)
z <- ifelse(x == 'students',0,1)
cor.test(data$identity,data$y)
cor.test(z,y)
x = 1:1:20
y = 2*x+rnorm(20,0,2)
cor.test(x,y,method = 'pearson')
# 画图
emmip(res,Time ~ Group, CIs = TRUE)
rm(list=ls())
library('readxl')
data = read_xlsx('hw9_data.xlsx')
data$Group <- as.factor(data$Group)
#正态性检验
library(rstatix)
data %>%
group_by(Group) %>%
shapiro_test(Pre,Mid,Post)
# 方差同质 + 球形检验 + 方差分析
library(bruceR)
res <- MANOVA(data, dvs = 'Pre:Post',dvs.pattern = '(.*)',
between = "Group",within = "Time",
sph.correction="GG")
EMMEANS(res,effect = "Time", p.adjust = "Scheffe")
#固定Time，比较Group
EMMEANS(res,effect = "Group", by = "Time")
#固定Group，比较Time
EMMEANS(res,effect = "Time", by = "Group")
# 画图
emmip(res,Time ~ Group, CIs = TRUE)
# 画图
emmip(res,Time ~ Group, CIs = TRUE)
x <- c(156,168,178,192)
y <- c(60,63,75,88)
cor(x,y,method = 'pearson') # pearson相关系数
x <- 0:0.5:4
y <- (x-2)^2
plot(x,y)
cor.test(x,y)
# 当然用cor也可以，但是基本还是需要输出p值
x <- c(156,168,178,192)
y <- c(60,63,75,88)
cor.test(x,y,method = 'spearman') # 相关系数
